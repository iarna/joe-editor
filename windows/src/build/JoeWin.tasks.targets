<?xml version="1.0" encoding="utf-8"?>
<!--
   This file is part of Joe's Own Editor for Windows.
   Copyright (c) 2015 John J. Jordan.
 
   Joe's Own Editor for Windows is free software: you can redistribute it
   and/or modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation, either version 2 of the
   License, or (at your option) any later version.
 
   Joe's Own Editor for Windows is distributed in the hope that it will
   be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with Joe's Own Editor for Windows.  If not, see
   <http://www.gnu.org/licenses/>.
-->

<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- UNIX to DOS copy task -->
  <UsingTask TaskName="CopyConvertLF" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll">
    <ParameterGroup>
      <SourceFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True" />
      <DestinationFolder ParameterType="System.String" Required="False" />
      <DestinationFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="False" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
<![CDATA[

for (int i = 0; i < SourceFiles.Length; i++)
{
    var srcfile = SourceFiles[i];
    string filename = srcfile.GetMetadata("FullPath");
    byte[] infile = File.ReadAllBytes(filename);
    string outfilename;
    
    if (DestinationFolder != null)
    {
        outfilename = Path.Combine(DestinationFolder, Path.GetFileName(filename));
    }
    else
    {
        outfilename = DestinationFiles[i].GetMetadata("FullPath");
    }
    
    using (var outf = File.Open(outfilename, FileMode.Create, FileAccess.Write))
    {
        int lastWrite = 0;
        for (int t = 0; t < infile.Length; t++)
        {
            if (infile[t] == 10 && infile[Math.Max(0, t - 1)] != 13)
            {
                infile[t] = 13; // I'm all about avoiding that extra Write =p
                outf.Write(infile, lastWrite, t - lastWrite + 1);
                infile[t] = 10;
                lastWrite = t;
            }
        }
    
        outf.Write(infile, lastWrite, infile.Length - lastWrite);
    }
}

]]>
      </Code>
    </Task>
  </UsingTask>
  
  <!-- Build .rc files from .spec files -->
  <UsingTask TaskName="JWGenerateResources" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll">
    <ParameterGroup>
      <Specs ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True" />
      <FileLocation ParameterType="System.String" Required="True" />
      <OutputFile ParameterType="System.String" Required="True" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
<![CDATA[

List<string> files = new List<string>(this.Specs.Select(s => s.GetMetadata("FullPath")));

if (files.Count == 0) return true;

using (var outs = new StreamWriter(File.Open(this.OutputFile, FileMode.Create, FileAccess.Write)))
{
    for (int i = 0; i < files.Count; i++)
    {
        foreach (string line in File.ReadAllLines(files[i]))
        {
            string s = line.Trim();
            if (string.IsNullOrEmpty(s)) continue;
            
            if (s.StartsWith("#include"))
            {
                string incfile = s.Substring(s.IndexOf(' ')).Trim();
                files.Add(Path.Combine(Path.GetDirectoryName(files[i]), incfile));
                continue;
            }
            
            List<string> options = null;
            
            if (s.Contains('['))
            {
                int lb = s.IndexOf('[');
                int rb = s.IndexOf(']');
                string opts = s.Substring(lb + 1, rb - lb - 1);
                options = opts.Split().ToList();
                s = s.Substring(0, lb).Trim();
            }
            
            string srcfile, dstfile;
            
            if (s.Contains("=>"))
            {
                string[] parts = s.Split(new string[] { "=>" }, StringSplitOptions.None);
                srcfile = parts[0].Trim();
                dstfile = parts[1].Trim();
            }
            else
            {
                srcfile = dstfile = s;
            }
            
            string actualFile = Path.Combine(this.FileLocation, srcfile);
            if (!File.Exists(actualFile))
            {
                this.Success = false;
                Log.LogError("Input file does not exist: {0}", actualFile);
                return false;
            }
            
            if (options != null && options.Contains("compress"))
            {
                string zname = actualFile + ".dfl";
                if (!File.Exists(zname) || File.GetLastWriteTime(zname) < File.GetLastWriteTime(actualFile))
                {
                    // Creation must be atomic (these run in parallel!)
                    string lockname = zname + ".lock";
                    Stream lockStream = null;
                    try
                    {
                        lockStream = File.Open(lockname, FileMode.CreateNew /* atomic */, FileAccess.Write);
                        
                        using (var zstream = File.Open(zname, FileMode.Create, FileAccess.Write))
                        {
                            // Write short header
                            byte[] hdr = { 5, 1 };
                            zstream.Write(hdr, 0, 2);
                            
                            using (var dstream = new DeflateStream(zstream, CompressionLevel.Optimal))
                            {
                                using (var istream = File.Open(actualFile, FileMode.Open, FileAccess.Read))
                                {
                                    istream.CopyTo(dstream, 8192);
                                }
                            }
                        }
                    }
                    catch
                    {
                        /* Pass */
                    }
                    finally
                    {
                        if (lockStream != null)
                        {
                            lockStream.Dispose();
                            File.Delete(lockname);
                        }
                    }
                }
                
                actualFile = zname;
            }
            
            outs.WriteLine(string.Format("F:*{0} RCDATA \"{1}\"", dstfile, actualFile.Replace(@"\", @"\\")));
        }
    }
}

]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
