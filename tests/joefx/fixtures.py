
import os

# Helper types for managing the files in JOE's environment.
# The idea is that you should set up these objects for how you want the
# directories to look before starting JOE, then run setup() to finalize
# (delete all files that don't belong and add the ones you want)

# If a complicated setup is required, you can create a proper unittest fixture
# class, which calls into these functions to perform that setup in its setUp method
# and add that class as a base class to all test classes that will use it.

class FixtureDir(object):
    """Handles a fixture directory"""
    def __init__(self, path, fixturesdir):
        self.files = {}
        self.path = path
        self.fixturesdir = fixturesdir
    
    def dir(self, name):
        """Gets a fixture subdirectory underneath this one with the specified name"""
        if name not in self.files:
            f = self.files[name]
            assert isinstance(f, FixtureDir)
            return f
        
        f = FixtureDir(os.path.join(self.path, name), self.fixturesdir)
        self.files[name] = f
        return f
    
    def fixtureFile(self, name, fixfile):
        """Set a fixture file with 'name' that will be copied file specified by fixfile (and found in the fixtures dir)"""
        assert name not in self.files
        self.files[name] = FixtureFile(os.path.join(self.fixturesdir, fixfile))
    
    def fixtureData(self, name, data):
        """Set a fixture file with 'name' that will contain the contents specified by data"""
        assert name not in self.files
        self.files[name] = FixtureRawFile(data)
    
    def fixtureFunc(self, name, func):
        """Set a fixture file with 'name' whose contents will be generated by the specified function"""
        assert name not in self.files
        self.files[name] = FixtureFunction(func)
    
    def setup(self):
        """Setup target directory to match what's in this model"""
        # Delete first
        toadd = list(self.files.keys())
        tomerge = []
        for f in os.listdir(self.path):
            path = os.path.join(self.path, f)
            if f not in self.files:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.unlink(path)
            else:
                toadd.remove(f)
                tomerge.append(f)
        
        # Add
        for f in toadd:
            self.files[f].create(os.path.join(self.path, f))
        
        # Merge
        for f in tomerge:
            self.files[f].merge(os.path.join(self.path, f))
    
    def create(self, path):
        os.mkdir(path)
        self.setup()
    
    def merge(self, path):
        self.setup()

class FixtureFile(object):
    def __init__(self, path):
        self.path = path
    
    def create(self, path):
        shutil.copyfile(self.path, path)
    
    def merge(self, path):
        if not compareFiles(self.path, path):
            os.unlink(path)
            self.create(path)

class FixtureRawFile(object):
    def __init__(self, data):
        self.data = data.encode('utf-8') if isinstance(data, str) else data
    
    def create(self, path):
        with open(path, 'wb') as f:
            f.write(self.data)
    
    def merge(self, path):
        if not compareFileWithBytes(path, self.data):
            os.unlink(path)
            self.create(path)

class FixtureFunction(object):
    def __init__(self, func):
        self.func = func
    
    def create(self, path):
        self._writeFile(path, self._getData())
    
    def merge(self, path):
        data = self._getData()
        if not compareFileWithBytes(path, data):
            os.unlink(path)
            self._writeFile(path, data)
    
    def _getData(self):
        data = self.func()
        return data.encode('utf-8') if isinstance(data, str) else data
    
    def _writeFile(self, path, data):
        with open(path, 'wb') as f:
            f.write(data)

# It's better to read a file than to write one, so if it hasn't changed then leave it alone.

CMP_SIZE = 1024

def compareFileWithBytes(path, b):
    buf = bytearray(CMP_SIZE)
    baseline = memoryview(b)
    current = memoryview(buf)
    pos = 0
    with open(path, 'rb') as f:
        while True:
            cnt = f.readinto(buf)
            if cnt < 1:
                return pos == len(b)
            if current[:cnt] != baseline[pos:pos + cnt]:
                return False
            pos += cnt

def compareFiles(path1, path2):
    if os.path.getsize(path1) != os.path.getsize(path2):
        return False
    
    buf1, buf2 = bytearray(CMP_SIZE), bytearray(CMP_SIZE)
    mv1, mv2 = memoryview(buf1), memoryview(buf2)
    pos = 0
    
    with open(path1, 'rb') as f, open(path2, 'rb') as g:
        while True:
            cnt = f.readinto(buf1)
            if g.readinto(buf2) != cnt:
                return False
            if cnt < 1:
                return True
            if mv1[:cnt] != mv2[:cnt]:
                return False
            pos += cnt
