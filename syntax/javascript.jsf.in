# JOE syntax highlight file for Javascript
# Based on java.jsf

# TODO:
# Ensure number and string formats are to spec.

=Idle
=Preproc 	blue
=Comment 	green
=Constant 	cyan
=Escape 	bold cyan
=Type 		bold
=Keyword 	bold
=Bad		bold red
=Brace		magenta
=Regex		yellow
=Control

:begin Idle
	*	begin	noeat call=.javascript()

.subr javascript

:idle Idle
	*		idle
	"/"		slash
	"0"		first_digit		recolor=-1
	"1-9"		decimal			recolor=-1
	"."		maybe_float
	"\""		after_value		call=.string(double) recolor=-1
	"'"		after_value		call=.string(single) recolor=-1
	"a-zA-Z_$"	ident			buffer
	"{}"		brace			recolor=-1
	")]"		control_after_value	recolor=-1
	",:;=(>[*&|!~+\-%^" control		recolor=-1
.ifdef script
	"<"		maybe_done
.else
	"<"		control			recolor=-1
.endif

# We need to keep track of what the last token was so that we
# can distinguish between '/' meaning "divide" from '/' meaning
# "regular expression".  Basically, regexes don't come directly 
# after other values, so anything that represents a value should
# come back to this state (almost everything here) and slashes
# will be treated like divides.
:after_value Idle
	*		idle			noeat
	" \t\f"		after_value
	"/"		slash_noregex		recolor=-1

:maybe_done Control
	*		idle			noeat
	"/"		idle			noeat return recolor=-2

:brace Brace
	*		idle			noeat

:control Control
	*		idle			noeat

# Control characters that might represent the end of a value ')]'
:control_after_value Control
	*		after_value		noeat

:slash Idle
	*		regex			noeat recolor=-2
	"*"		comment			recolor=-2
	"/"		line_comment		recolor=-2

:slash_noregex Idle
	*		idle			noeat
	"/"		line_comment		recolor=-2
	"*"		comment_noregex		recolor=-2
	"\r\n"		idle

:regex Regex
	*		regex
	"\\"		regex_escape
	"/"		regex_end
	"\r\n"		idle

:regex_escape Regex
	*		regex
	"\r\n"		idle

:regex_end Regex
	*		after_value		noeat
	"a-zA-Z"	regex_end

:comment Comment
	*		comment
	"*"		maybe_end_comment

:maybe_end_comment Comment
	*		comment
	"/"		idle
	"*"		maybe_end_comment

# Track after value state through winged comments, too.
:comment_noregex Comment
	*		comment_noregex
	"*"		maybe_end_comment_noregex

:maybe_end_comment_noregex Comment
	*		comment_noregex
	"/"		after_value
	"*"		maybe_end_comment

:line_comment Comment
	*		line_comment
	"\n"		idle

:first_digit Constant
	*		after_value		noeat
	"xX"		hex
	"."		float
	"eE"		epart
	"0-7"		octal
	"89"		bad_number		recolor=-1

:bad_number Bad
	*		after_value		noeat
	"0-9"		bad_number

:octal Constant
	*		after_value		noeat
	"0-7"		octal
	"89"		bad_number		recolor=-1

:hex Constant
	*		after_value		noeat
	"0-9A-Fa-f"	hex

:decimal Constant
	*		after_value		noeat
	"0-9"		decimal
	"eE"		epart
	"."		float

:maybe_float Constant
	*		idle			noeat recolor=-2
	"0-9"		float			recolor=-2

:float Constant
	*		after_value		noeat
	"eE"		epart
	"0-9"		float

:epart Constant
	*		after_value		noeat
	"0-9+\-"	enum

:enum Constant
	*		after_value		noeat
	"0-9"		enum

.ifdef typescript

:ident Idle
	*		after_value		noeat strings
	"break"		kw
	"case"		kw
	"catch"		kw
	"continue"	kw
	"debugger"	kw
	"default"	kw
	"delete"	kw
	"do"		kw
	"else"		kw
	"finally"	kw
	"for"		kw
	"function"	kw
	"if"		kw
	"in"		kw
	"instanceof"	kw
	"new"		kw
	"return"	kw
	"switch"	kw
	"this"		kw
	"throw"		kw
	"try"		kw
	"typeof"	kw
	"var"		kw
	"while"		kw
	"with"		kw
	
	"true"		lit
	"false"		lit
	"null"		lit
	"undefined"	lit
	
	# Typescript-specific
	"class"		kw
	"constructor"	kw
	"declare"	kw
	"enum"		kw
	"extends"	kw
	"export"	kw
	"get"		kw
	"implements"	kw
	"import"	kw
	"interface"	kw
	"module"	kw
	"namespace"	kw
	"private"	kw
	"public"	kw
	"require"	kw
	"set"		kw
	"static"	kw
	"super"		kw
	
	"any"		type
	"boolean"	type
	"number"	type
	"string"	type
	"void"		type

done 
	"a-zA-Z0-9_$"	ident

.else

:ident Idle
	*		after_value		noeat strings
	"break"		kw
	"case"		kw
	"catch"		kw
	"continue"	kw
	"debugger"	kw
	"default"	kw
	"delete"	kw
	"do"		kw
	"else"		kw
	"finally"	kw
	"for"		kw
	"function"	kw
	"if"		kw
	"in"		kw
	"instanceof"	kw
	"new"		kw
	"return"	kw
	"switch"	kw
	"this"		kw
	"throw"		kw
	"try"		kw
	"typeof"	kw
	"var"		kw
	"void"		kw
	"while"		kw
	"with"		kw

	"true"		lit
	"false"		lit
	"null"		lit
	"undefined"	lit
done 
	"a-zA-Z0-9_$"	ident

.endif

:type Type
	*	after_value			noeat

:kw Keyword
	*	after_value			noeat

:lit Constant
	*	after_value			noeat

.end

.subr string

:string Constant
	*		string
.ifdef double
	"\""		idle			return
.endif
.ifdef single
	"'"		idle			return
.endif
	"\\"		string_escape		recolor=-1
	"\n"		string			return

:string_escape Escape
	*		string
	"x"		string_hex2
	"u"		string_uni
	"0-7"		string_octal3
	"\n"		string			recolor=-2

:string_hex1 Escape
	*		string			noeat
	"0-9a-fA-F"	string

:string_hex2 Escape
	*		string			noeat
	"0-9a-fA-F"	string_hex1

:string_hex3 Escape
	*		string			noeat
	"0-9a-fA-F"	string_hex2

:string_hex4 Escape
	*		string			noeat
	"0-9a-fA-F"	string_hex3

:string_uni Escape
	*		string_hex4		noeat
	"{"		string_univariable

:string_univariable Escape
	*		string			noeat
	"0-9a-fA-F"	string_univariable
	"}"		string

:string_octal2 Escape
	*		string			noeat
	"oO"		string_octal2
	"0-7"		string_octal1

:string_octal1 Escape
	*		string			noeat
	"0-7"		string

.end
